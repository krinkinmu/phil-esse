\section{Этап миниатюризации}

Переход к этапу миниатюризации связан с появлением и распространением микрокомпьютеров. Микрокомпьютер - небольшая, сравнительно недорогая универсальная ЭВМ. Интересно, что термин микрокомпьютер появился еще 1956 году в рассказе Айзека Азимова «The Dying Night». Миниатюрные ЭВМ появлялись и раньше, но они были либо не универсальными (как например, HP9100А — сейчас его бы назвали научным калькулятором), либо были дорогими (как например, HP9845 — самый развитый представитель серии HP9800~\cite{HP9800}). С появлением миниатюрных дешевых ЭВМ каждый программист, и не только в больших компаниях, мог иметь свой собственный компьютер на рабочем месте.

Первым персональным компьютером в его привычном понимании можно назвать Xerox Star workstation, который уже имел графический интерфейс (окна, иконки и др), мышь, Ethernet, набор ПО (файловый сервер, сервер печати, почтовый клиент)~\cite{PCHIST} — все то, что привычно для нас сейчас. Xerox Star так и не стал пользоваться большой популярностью. Но появление графического интерфейса и мыши сделали ПО гораздо ближе к пользователю. Потребность в ПО продолжает расти, растут требования и сложность ПО. Идеи структурного программирования не справляются с возрастающей сложностью программ. Ответом стало объектно-ориентированное программирование. В области организации процесса разработки ПО, как следствие расширения области применения компьютеров, все более активно развиваются альтернативы классическому «водопаду» возникают RAD (быстрая разработка программ) и гибкие методологии.

\subsection{Объектно-ориентированное программирование}

В отличие от структурного программирования со строгими теоретическими основами, появившееся из академической среды, объектно-ориентированное программирование — результат переработки огромного количества опыта в недрах коммерческих компаний (в этой связи стоит отметить как раз компанию Xerox). До 80-х годов общепризнанная модель вычисления заключалась в постепенной трансформации входных данных из их начального состояния в конечный результат — главным был поток данных программы, над котором последовательно выполнялись трансформации. В самой простой форме это напоминало работу конечного автомата. Такой подход хорошо согласовывался с изначальной задачей компьютера — численными расчетами. Стоит отметить, что объектно-ориентированная парадигма не противопоставляется структурному программированию, она расширяет ее и предлагает больше абстракций и средств декомпозиции программ.

Корни объектно-ориентированного программирования уходят в 60-е года. Где в контексте задач компьютерного моделирования сложных систем (железные дороги, фабрики и пр) появляется идея объекта, отражающего моделируемые объекты реального мира. Объекты появляются и исчезают, проходя в процессе работы программы через фазы своего собственного жизненного цикла. Каждый объект несет с собой набор закрытых данных, отражающих его текущее состояние. Такой подход к решению задач был очень естественным в моделировании дискретных систем. Некоторые ЯВУ из 60-х годов уже поддерживали концепцию объектов, однако свое распространение она получила только в 80-х годах. Идею объектно-ориентированного программирования в ее современном виде связывают с появлением языка Smalltalk.

Современное объектно-ориентированное программирование также базируется на понятии объекта, который несет некоторые внутренние данные, отражающие его состояние и определяет некоторый интерфейс — набор операций, которые позволяют менять состояние объекта (и данные и операции над ними связаны вместе и рассматриваются как единое целое). А программа — это набор взаимодействующих объектов, т. е. происходит отход от централизации управления (программа последовательно трансформирует данные) в пользу децентрализации (каждый объект сам работает со своей порцией данных). Впрочем, теперь объекты программы не всегда соответствуют объектам реального мира.

Идея сокрытия деталей внутреннего представления объектов за интерфейсом получила название инкапсуляции. Инкапсуляция является дальнейшим развитием идей модульности в ПО и переиспользования программных компонент. Т. е. мы можем подменить одну реализацию внутреннего состояния объекта, сохранив при этом тот же самый интерфейс, без необходимости внесения изменений в другие части программы, которые используют данный объект. Таким образом мы можем создавать целые библиотеки классов и многократно их переиспользовать (так же как и с библиотеками подпрограмм).

Вместе с понятием объекта стоит упомянуть и понятие класса. Класс можно определять по разному. Иногда класс определяют как совокупность схожих объектов, т. е. объектов одного типа, которые отличаются только конкретными внутренними состояниями. Иногда класс определяют как прототип, на основании которого создаются конкретные объекты, т. е. класс определяет как представляется внутренне состояние объекта и какие действия можно производить над объектом (операции объекта, его интерфейс). Оба подхода в равной степени распространены и используются.

Другой важной концепцией объектно-ориентированного подхода является наследование. Наследование — это отношение между классами объектов. Например, пусть в программе присутствуют классы «Млекопитающее» и «Кошка». Здравый смысл подсказывает, что любой представитель класса «Кошка» является также и представителем класса «Млекопитающее». Такое отношение между классами и выражается наследованием — говорят что класс «Кошка» наследует класс «Млекопитающее». С точки зрения ПИ наследование выступает как способ избежать дублирования кода, или как способ переиспользовать уже написанный код. Идея заключается в том, что реализовав один раз операцию для класса «Млекопитающее», нам не потребуется реализовывать ее еще раз для класса «Кошка», потому что они связаны отношением наследования и все, что реализовано для класса «Млекопитающее» досталось в наследство и классу «Кошка».

В данный момент объектно-ориентированное программирование является одной из самых широко используемых парадигм. Тело объектно-ориентированного программирования составляют как высокоуровневые принципы, например, SOLID~\cite{SOLID}, так и вполне конкретные паттерны решения часто встречающихся проблем. Например, в работе~\cite{Gamma:1995:DPE} собраны и классифицированы 23 таких паттерна проектирования. Паттерн проектирования применительно к ПИ — это повторимая архитектурная конструкция, представляющая решение проблемы проектирования в рамках некоторого часто возникающего контекста~\cite{SDP}.

\subsection{Быстрое прототипирование}

Быстрая разработка программ (RAD) — группа методологий, которые противопоставляются классическому «водопаду» и его последователям. Основная идея заключается в итеративности процесса разработки и быстром прототипировании. Собственно первая такая методология, предложенная Барри Боемом, называется спиральной. В спиральной методологии выделяются следующие фазы: анализ (определение целей, ограничений и различных альтернатив), оценка (определение рисков, оценка альтернатив, прототипирование), реализация (кодирование и тестирование), планирование следующей фазы~\cite{Boehm:1988:SMSD}. И эти фазы повторяются циклически в процессе разработки.

Быстрая разработка программ существенно отличается от «водопада» наличием прототипов, в противовес «водопаду», когда мы имеем только готовый программный продукт на выходе (вспомните о философии Unix, о которой было сказано выше). Прототипы дают три существенных преимущества. Во-первых, явный учет рисков и их минимизация. Реализация прототипа дает ценную информацию о сложности реализации тех или иных решений, что и позволяет управлять рисками. Во-вторых, заказчики зачастую не могут четко сформулировать свои требования к ПО, гораздо проще попробовать некоторый прототип и высказать пожелания о его исправлении, доработке. В-третьих, прототипы сами по себе могут быть функционирующим ПО, т. е. работающее решение, возможно с минимумом необходимых функций, получается гораздо раньше и его уже можно использовать.

Для быстрого создания прототипов предполагается использование специальных инструментальных средств (Computer Assited Software Engineering tools или просто CASE) на всех уровнях процесса разработки от создания дизайна (различные редакторы диаграмм, планировщики, генераторы документов) до реализации (визуальные языки, генераторы кода и др). Такие средства хорошо работают с типовыми проектами (например, множество компаний имеют свои сайты в Интернет, между которыми кроме внешнего вида, зачастую, нет серьезных различий).

Конечно у такого подхода есть и ряд существенных недостатков. Например, заказчик гораздо сильнее вовлечен в процесс разработки, чем ему, возможно, хотелось (впрочем это не будет проблемой, если заказчика нет). Кроме того CASE средства не так хороши для не типовых проектов.

\subsection{Гибкие методологии}

Гибкие методологии (Agile) — это группа методов организации процесса разработки, акцентирующих внимание на эффективном взаимодействии между программными инженерами, и нацеленные на небольшие группы разработчиков (порядка 10 человек). Название «гибкие методологии» они получили за возможность быстрой смены акцентов и направления разработки, чтобы адаптироваться к быстро меняющимся внешним условиям (например, реакции пользователей на продукт, появление новых технологий и др.).

Каждая конкретная гибкая методология (экстремальное программирование, scrum и др.) определяет свой собственный набор методов и правил, но все они имеют общие идеи и принципы. Эти идеи и принципы в 2001 году были зафиксированы в форме Agile-манифеста разработки ПО~\cite{Agile}. Четыре основных положения манифеста:
\begin{itemize}
  \item люди и взаимодействие важнее процессов и инструментов;
  \item работающий продукт важнее исчерпывающей документации;
  \item сотрудничество с заказчиком важнее согласования условий контракта;
  \item готовность к изменениям важнее следования первоначальному плану;
\end{itemize}

Создатели манифеста подчеркивают, что они не отрицаются важности процессов и инструментов, исчерпывающей документации, согласования условий контракта и следования первоначальному плану, они лишь понижают их приоритет.
