\section{Освоение машины}

Новый этап начинается с середины 50-х годов. Постепенно на смену ламповым ЭВМ стали приходить транзисторные ЭВМ. Бурное развитие технологий привело к тому, что компьютеры сменяли друг друга каждые пару лет (IBM-701, TRADIAC, Pegasus, Philco-2000, Elliot-803, Siemens-2002, H-1, IBM-7030, Atlas, CDC-6600)~\cite{Glass}. Программирование, в основном сводится, к переписыванию старых программ для новых ЭВМ.

В этот период компьютеры становятся доступны исследовательским институтам и университетам. Их выход за пределы закрытых лабораторий электро-инженеров означает, что программирование стало занятием большего числа людей. Использование компьютера выглядит очень необычно по современным меркам. Программист отдает программу диспетчеру, который поставит программу на исполнение и вернет результаты работы через часы или даже дни. Т. е. никакой интерактивности и уж тем более собственного компьютера~\cite{Wirth:2008:HIST}.

ПИ как самостоятельно дисциплины все еще не существует, программированием занимаются математики и инженеры электротехники. Нет учебных дисциплин нацеленных на ПИ в целом и программирование в частности. Не существует и понятия управления программными проектами, предсказывать сроки завершения программных проектов практически невозможно. Бессистемный подход к разработке программ этого этапа можно, условно, обозначить как «Code and Fix» - сначала пишется код, потом исправляются проблемы в этом коде, т. е. сначала идет реализация, а потом уже задумываются о требованиях, дизайне, тестировании и прочем~\cite{Boehm:1988:SMSD}.

Программам не уделяется особого внимания — они просто бесплатное дополнение к ЭВМ. Это довольно курьезное положение дел, по двум причинам. Во-первых, программируемые ЭВМ бесполезны без программ. Во-вторых, программирование считается сложной задачей, требующей изучения\footnote{Этап называется освоение машины, т. е. требуется изучение конкретной ЭВМ.} и упорства. Чтобы облегчить кодирование появляются приближенные к человеку формальные языки, то что мы сейчас называем языками программирования высокого уровня~\cite{Wirth:2008:HIST}.

\subsection{Языки высокого уровня}

Языки высокого уровня (ЯВУ) - изначально, формальные языки описания программ, обладающий большей степень абстрактности, чем язык машинных команд~\cite{HLPL}. Чтобы было понятно, при использовании машинного языка, программист думает в понятиях регистров, памяти, машинных слов, бит и инструкций компьютера. При использовании языков высокого уровня программист использует числа, символы, строки, арифметические операции, типы и структуры данных. А трансляция этих понятий на низкоуровневые возможности ЭВМ выполняется механически с помощью компилятора.

Можно отметить несколько значимых языков программирования, разработанных на ранних этапах развития ПИ: FORTRAN, LISP, COBOL, Algol и PL/1. Это не первые ЯВУ, но их можно назвать самыми заметными в ранней истории ПИ. Сейчас, спустя много лет, на некоторые из них, мы смотрим, скорее, как на отрицательные примеры, чем как на положительные, но это не отрицает их важности~\footnote{Отрицательный опыт тоже важен.}.

Высокоуровневые понятия, которые использовались в ЯВУ того времени соответствовали задачам, решаемым с помощью компьютеров. Т. е. они, за некоторым исключением, были "заточены" под численные расчеты. Языки не обладавшие конкретной специализацией считались игрушками. Например, "LISP описывали как "наиболее умный способ неправильно использовать компьютер"~\cite{Dijkstra:1972:HP}, и именно LISP в наши дни можно считать примером удачного ЯВУ.

\paragraph{FORTRAN} (FORmula TRANslator, 1957) — первый ЯВУ получивший действительно широкое распространение. Чтобы подчеркнуть значимость этой разработки, достаточно упомянуть, что язык FORTRAN до сих пор используется, не так широко и активно как раньше — его применения сократилось до весьма узкого использования в научных вычислениях, но это все равно совершенно удивительный срок жизни для технологии~\footnote{Имеется ввиду именно FORTRAN, а не сама идея ЯВУ.} в области ПИ. Впрочем не смотря на всю значительность этой разработки, можно констатировать, что язык FORTRAN безнадежно устарел, и как отметил Дейкстра: "чем раньше мы забудем, что FORTRAN когда-либо существовал, тем лучше"~\cite{Dijkstra:1972:HP}.

\paragraph{LISP} (LISt Processing language, 1958), в отличие от FORTRAN, даже спустя много лет рассматривается как положительный опыт в истории ПИ. В начале своего появления, он не пользовался большой популярностью, однако, стоит заметить, что свое применение он все же нашел — в области искусственного интеллекта он был основным языком, вероятно за свою исключительную простоту и выразительность. LISP базировался на небольшом количестве простых идей, которые показали удивительную стойкость~\cite{Dikkstra:1972:HP}. LISP был совершенно отличен от FORTRAN, и многие современные технологии появились впервые именно в LISP: автоматическое управление памятью~\footnote{Активно используется очень многими современными языками программирования, например, целой группой языков для JVM, Python, JavaScript и др.}, динамическая типизация~\footnote{Мнение об этой концепции в среде ПИ не однозначно, есть сторонники такого подхода, есть противники, есть те, кто признают важность и динамической и статической типизации.}, функции высшего порядка~\footnote{Функции, которые принимают функции, как аргумент или возвращают их как результат своей работы - одна из интересных реализаций идеи подпрограммы.} и др. Как и FORTRAN LISP до сих пор используется в виде множества различных более современных диалектов, сохраняющих общие концепции с оригинальной разработкой.

\paragraph{COBOL} (COmmon Buisness Oriented Language, 1960) отличается и от FORTRAN и от LISP, его специализация - бизнес приложения. Т. е. приложения нацеленные не на математические расчеты, а на хранение и поиск информации, например, банковские системы. Все предложения на COBOL составлялись из слов английского языка, даже для обозначения таких операций как сложение приходилось писать "ADD a TO b" или "SUBTRACT a FROM b". В последствии COBOL будут ругать за его многословность. COBOL проектировался так, чтобы быть простым и переносимым. Особенно остановимся на переносимости, программы на COBOL должны были работать на всем том множестве компьютеров без изменения. В конечном итоге компьютер и программа лишь инструмент и вкладывать деньги в написание новой программы для нового компьютера, или потому что появилась новая технология зачастую неприемлемо. Поэтому бизнес приложения с возрастом в 10, 20, а то и больше лет не редкость. И COBOL должен был удовлетворить эти нужды, и он до сих пор используется~\cite{Mitchell:2006:CND} для жтих целей.

Итак, ЯВУ изначально были созданы, чтобы облегчить написание программ, чтобы приблизить описание программы к человеку и предоставить абстракцию не привязанную к ЭВМ. Сейчас ЯВУ ушли далеко за пределы только описания программ. Например, существуют полу-формальные графические языки для описания алгоритмов, дизайна программ, описания вариантов использования и много другого~\footnote{Здесь имеются ввиду различные блок-схемы/flowcharts и UML.}. Собственно языков программирования существует теперь великое множество, все они обладают своими особенностями, поддерживают различные парадигмы, имеют свою область применения. Само понятие ЯВУ претерпело со временем множество изменений - для первых языков числа, строки и файлы~\footnote{Это про COBOL.} были существенным уровнем абстракции, теперь же никого не удивишь полиморфизмом и абстрактными типами данных. Поэтому понятие ЯВУ я причисляю к идеям ПИ. Стоит отметить, что и в других инженерных дисциплинах есть свои формальные языки, но в ПИ их выбор существенно больше и разнообразнее, и не ограничен какими-либо стандартами~\footnote{Государственными или отраслевыми.}.
