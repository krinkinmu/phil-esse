\section{Освоение сложности}

Переход к новому этапу связан с появлением миниатюрных компьютеров~\footnote{Имеются ввиду персональные компьютеры в их современном понимании и их предшественники.} и сильным снижением цен на ЭВМ. Теперь каждый программист может иметь свой собственный компьютер на рабочем месте, более того люди могут позволить иметь себе домашний компьютер.

Первым персональным компьютером в его привычном понимании можно назвать Xerox Star Workstation, который уже имел графический интерфейс (окна, иконки и др), мышь, Ethernet, набор ПО (файловый сервер, сервер печати, почтовый клиент)~\cite{PCHIST} — все то, что привычно для нас сейчас.

Понятно, что это способствовало распространению ЭВМ. Но кроме этого, графический интерфейс и манипулятор сделали ЭВМ гораздо ближе к обычным пользователям. Все это привело к еще большей потребности в ПО. Программы становятся сложнее~\footnote{Как не трудно заметить, это вообще общая тенденция на всем протяжении истории ПИ.}. Очередные провалы в разработке ПО привели к необходимости поиска панацеи. Такой панацеей стала новая парадигма - объектно-ориентированное программирование. В отличие от структурного программирования со строгими теоретическими основами, появившегося из академической среды, объектно-ориентированное программирование — результат переработки накопленного опыта и синтеза лучших идей из существующих парадигм на протяжении довольно долгого периода истории.

На этом этапе также достигают существенного развития итеративные и инкрементальные методологии разработки, противопоставляющиеся классическим каскадным моделям.

\subsection{Объектно-ориентированное программирование}

До 80-х годов общепризнанная модель вычисления заключалась в постепенной трансформации входных данных из их начального состояния в конечный результат — главным был поток данных программы, над котором последовательно выполнялись трансформации. Такой подход хорошо согласовывался с изначальной задачей компьютера — численными расчетами~\cite{Wirth:2008:HIST}. Но с появлением персональных ЭВМ и в особенности графического интерфейса такая модель больше не могла удовлетворить все нужды промышленности.

Объектно-ориентированное программирование, введя понятие объекта, сместила акценты. В объектно-ориентированной парадигме программа рассматривается не как набор процедур преобразующих входные данные в выходные, а как набор взаимодействующих объектов. Объект обладает своим внутренним состоянием и набором методов, которые позволяют изменять внутренне состояние. При разработке программы в первую очередь выделяются объекты. Например, при разработке графического интерфейса, такими объектами могут быть окно, кнопка, буква.

Каждый объект сам по себе является простым, обладает своей областью ответственности, его легко разработать и протестировать. Но объекты можно компоновать друг с другом разными способами в сложные структуры. Буквы компонуются в текст, текст и кнопки в свою очередь составляют окно и т. д. Так преодолевается сложность программы.

Такой подход очень хорошо лег на человеческий образ мышления и получил широкую популярность, ведь по сути объекты программы отражали реальные объекты. Если на экране мы видим окно, то и в программе есть такой объект, если на экране мы видим кнопку, то и в программе есть объект представляющий ее. И это касается не только объектов графического интерфейса~\footnote{Справедливости ради отметим, что современное объектно-ориентированное программирование уже далеко не только отражение объектов реального мира - выделение таких объектов только половина дела, необходимо также построить эффективную схему их взаимодействия.}.

Хоть я и отношу объектно-ориентированное программирование к этому этапу, потому что именно здесь эта парадигма получила широкое распространение, однако история этой парадигмы начинается еще с 60-х годов. Как уже отмечалось выше, объектно-ориентированная парадигма является результатом синтеза существовавших ранее подходов и опыта накопленного при решении различных задач компьютерной симуляции. Создатель объектно-ориентированного программирования в ее нынешнем виде Алан Кей описал историю этой парадигмы с самых ранних этапов в работе~\cite{Kay:1996:EHS}.

В данный момент объектно-ориентированное программирование является одной из самых широко используемых парадигм. Тело объектно-ориентированного программирования составляют как высокоуровневые принципы, например, SOLID~\cite{SOLID}, так и вполне конкретные паттерны решения часто встречающихся проблем. Например, в работе~\cite{Gamma:1995:DPE} собраны и классифицированы 23 таких паттерна проектирования. Но вместе с тем объектно-ориентированное программирование стало и модной тенденцией, т. е. объектно-ориентированное программирование часто выбирают не потому, что это подходящий инструмент для данной задачи, но потому что это модно, что вряд ли можно назвать хорошей тенденцией~\cite{Wirth:2008:HIST}.

\subsection{Итеративные и инкрементальные методологии}

Вариации классической каскадной модели хорошо подходили для крупных организаций с высоким уровнем бюрократии~\footnote{Подходят ли они хорошо для разработки проектов - другой вопрос, сам автор классической каскадной модели, отмечал, что она не реалистична.}. Для таких организаций естественно спланировать проект заранее на продолжительный срок. Но теперь компьютеры появляются не только у крупных и неповоротливых организаций.

Как отмечается в работе~\cite{Brooks:1987:NSB}, заказчик зачастую не знает чего именно он хочет. Поэтому стадия сбора и анализа требований является самой сложной стадией во всем процессе разработки - очень легко пропустить или неправильно понять како-либо требование заказчика. При классической каскадной модели разработки эта ошибка будет выявлена слишком поздно, фактически, к концу процесса разработки. Стоимость ее исправления такой ошибки оказывается очень дорогой.

Кроме того изменяется специфика разработки ПО - все больше продуктов разрабатывается не по заказу. Программные проекты без заказчика разрабатываются пока на него есть спрос. Причем на рынке может существовать сразу несколько программ одного класса, т. е. между ними возникает конкуренция. При разработке проекта приходится учитывать меняющееся положение на рынке.

В связи с этим все большее распространение получают различные итеративные и инкрементальные модели разработки. Различные конкретные модели из этого большого класса нацелены на отслеживание и минимизацию рисков, на последовательное уточнение требований заказчика или на подстраивание под изменяющиеся требования рынка.

\paragraph{Спиральная модель разработки} предложенная Барри Боэмом~\cite{Boehm:1988:SMSD} рассчитана на выявление и управление рисками. Процесс разработки в этой модели представляется в виде спирали, каждый виток этой спирали состоят из фаз анализа, выявления рисков, разработки и тестирования, планирования. Т. е. каждая итерация представляет собой каскадную модель в миниатюре.

На фазе выявления рисков на каждом витке мы пытаемся идентифицировать возможные последствия того или иного архитектурного решения. Выбор между различными решениями осуществляется на основе реализации прототипа. Прототип не является готовым ПО, но позволяет конкретно оценить последствия тех или иных решений. Таким образом за счет прототипов осуществляется минимизация рисков.

Таким образом спиральная модель совмещает предсказуемость классической каскадной модели с достоинствами итеративных методов для минимизации рисков.

\paragraph{Модель "evolutionary delivery"}~\footnote{Дословный перевод отражает суть методологии, но звучит не очень по русски, литературный перевод мне не известен.} предложенная Томом Гилбом~\cite{Gilb:1985:EDV} ориентирована на итеративное выявление требований или подстраивание под изменяющие требования рынка.

Идея заключается в том, чтобы предоставить пользователю~\footnote{Который может являться или не является заказчиков в свете всего сказанного ранее.} некоторую начальную версию ПО. Собрать от пользователей информацию о достоинствах и недостатках ПО, желаниях по улучшению или добавлению новых возможностей. Переработать эту информацию в новые требования и доработать первую версию. И этот цикл повторяется. За счет этого проясняются требования пользователей, или выявляются новые требования рынка.

Как и с классической каскадной моделью, кроме приведенных выше методологий, существует множество различных вариаций итеративных и инкрементальных методологий, но все они объединены общими идеями. Как отметил Брукс в~\cite{Brooks:1987:NSB} сложное ПО нужно не строить и не собирать, его нужно выращивать. Итеративные и инкрементальные методологии реализуют эту биологическую метафору.

\paragraph{Гибкие методологии} - совокупное название инкрементальных итеративных методологий разработки, которые получили широкое распространение в 1990-х и 2000-х годах. Существует большое количество гибких методологий, но все они объединены общими идеями, зафиксированными в манифесте~\cite{Agile}. Основные идеи гибких методологий заключаются в активной коммуникации между членами команды разработки и между командой разработки и заказчиком, использовании частых итераций разработки. Основная цель - быстрая адаптация к меняющимся требованиям.
