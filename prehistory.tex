\section{Предыстория}

Первые программируемые универсальные ЭВМ~\footnote{универсальность в данном случае подчеркивается намерено, так как первые ЭВМ появились и использовались задолго до первых универсальных программируемых ЭВМ.} (EDVAC, EDSAC, MARK 1, LEO, UNIVAC, CSIRAC) появляются во второй половине 40-х годов. Основанные на идеях Алана Тьюринга~\cite{Kowalik:TURING}~\footnote{Алана Тьюринга считают отцом Computer Science, именно его имя носит самая престижная премия в этой области — премия Тьюринга. Все лауреаты этой премии готовят, так называемую, тьюринговскую лекцию. В этой работе я активно ссылаюсь на эти лекции.} и Джона фон Неймана~\cite{Lee:VONNEUMANN} они стали первыми универсальными ЭВМ.

Универсальными их делала именно возможность изменять программу, что дало старт развитию компьютерной техники в ее современном виде и положило начало программированию. Программы для первых компьютеров составлялись из набора очень простых инструкций (сохранить значение из заданного регистра в заданную ячейку памяти, извлечь значение из заданной ячейки памяти в регистр, выполнить арифметическое действие над содержимым двух регистров, выполнить логическое действие над содержимым двух регистров)~\cite{Turing}, потому что все эти инструкции необходимо было реализовывать аппаратно. Набор инструкций современных ЭВМ стал гораздо богаче, но суть не изменилась — каждая инструкция, как правило, представляет простое действие~\footnote{Иногда программисты называют ЭВМ "глупой железкой"}.

В производстве первых компьютеров использовались вакуумные трубки для реализации логических элементов и магнитные барабаны для реализации памяти. Они были очень дорогими в эксплуатации, потребляли много энергии и выделяли много тепла. Это и ненадежность электронных компонентов часто приводили к неполадкам\footnote{Современные компьютеры могут работать годы без остановки, в компьютерах на вакуумных трубках поломки случались раз в несколько дней.}. Вычислительная мощность по сравнению с современными компьютерами была просто мизерной.

Не смотря на все это первое поколение ЭВМ нашло свое применение. Первые компьютеры могли производить тысячи арифметических операций в секунду, т. е. на тот момент они были самыми быстрыми вычислительными устройствами. Стоимость первых ЭВМ была огромной и, конечно, финансировали исследования военные. Они впервые и начали их применять, например, ENIAC впервые был применен для расчетов связанных с термоядерным оружием~\cite{Randall:2006:ENIAC}. Однако очень скоро они нашли и коммерческое применение.

Программировались первые ЭВМ в языке машинных команд. Язык машинных команд был свой для каждой машины. Каждая инструкция, которую могла выполнить машина кодировалась некоторым числом (набором бит). Кодировались программы либо в виде отверстий на перфолентах или перфокартах, либо с помощью кабелей и переключателей.

Не трудно понять, что программирование первых ЭВМ было чрезвычайно трудоемким занятием и не считалось престижным~\footnote{Строго говоря, это даже не было самостоятельной профессией.}. Поэтому в это время программирование считалось женской работой, в то время как мужчины занимались более престижной разработкой аппаратной части. Примечательно, что теперь, когда программная инженерия стала очень престижной областью деятельности, в ней преобладают именно мужчины~\cite{CSWOMEN}.

\paragraph{Подпрограмма}. Первые ЭВМ разрабатывались для численных расчетов. Например, ENIAC создавался для расчета баллистических траекторий~\cite{Randall:2006:ENIAC}, поэтому обладал довольно специфичными инструкциями для решения линейных дифференциальных уравнений. Однако, чтобы решать другие задачи необходимо уметь группировать вместе несколько инструкций. Такие группы инструкций, которые вместе решают одну задачу и есть программа.

Эти программы могли быть довольно большими и сложными~\footnote{Всю историю ПИ можно рассматривать, как разработку средств борьбы со сложностью программ.}. Человеку создавать большие программы в таком неудобном подталкивающим к ошибкам представлении было довольно сложно. Дейкстра в~\cite{Dijkstra:1972:CIN} утверждает, что возможности человека по работе с информацией, в принципе, сильно ограниченны. И это мнение находит свое научное подтверждение~\cite{Miller}. Поэтому по необходимости должны были появится средства декомпозиции решаемых задач, в месте с ними и программ на части.

Подпрограмма — набор инструкций программы, выполняющих определенную задачу и собранный в одну структурную единицу, которую можно многократно переиспользовать. Набор инструкций входящих в подпрограмму мы будем называть телом подпрограммы. По сути, подпрограммы это первый способ декомпозиции программы. Такой простой подход очень естественен. После того как подпрограмма разработана, можно считать ее просто еще одна инструкций ЭВМ, которую можно использовать.

Различают открытые и закрытые подпрограммы. Суть открытых подпрограмм заключается в том, что программист явным образом должен вставить тело подпрограммы в нужное место программы. Т. е. они существуют только на этапе проектирования программы, но не во время выполнения, для программиста, но не для ЭВМ. Очевидно, для таких подпрограмм не требуется поддержка со стороны ЭВМ, так как она о них ничего не знает.

Закрытые подпрограммы, в отличие от открытых, существуют на этапе исполнения программы. Тело закрытой подпрограммы присутствует в программе в единственном экземпляре, а чтобы использовать его необходимо вызвать подпрограмму — передать ей управление. По завершении подпрограмма должна вернуть управление вызвавшей ее части программы. По сравнению с открытыми подпрограммами закрытые требуют меньше памяти, так как тело закрытых подпрограмм не дублируется, но при этом для них требуется поддержка со стороны ЭВМ.

Понятно, что открытые подпрограммы присутствовали с самого начала программирования, но интересно, что некоторые первые ЭВМ уже проектировались с поддержкой закрытых подпрограмм (инструкции BURRY и UNBURRY в~\cite{Turing},~\cite{Dijkstra:1972:HP}).

Итак, подпрограммы выполняют структурную функцию, позволяют экономить ресурсы ЭВМ, но кроме этого они еще позволяют очевидным образом экономить ресурсы человеческие. Подпрограмму написанную один раз можно использовать многократно. В современном программировании существует огромное количество самых разнообразных библиотек подпрограмм, которые используются в множестве программных проектов и для создания других библиотек подпрограмм. Фактически, главный принцип ПИ — не дублировать уже проделанную работу, впервые поддерживался подпрограммами~\footnote{Часто можно встретить фразу «изобретать велосипед», что значит повторять уже проделанную работу.}.

Кроме уже сказанного, подпрограммы повышают надежность программ. Эта выгода была менее значимой в ранний период ПИ, но ее нельзя переоценить в современной ПИ. При создании программ люди неизбежно допускают ошибки. Нахождение и исправление этих ошибок является частью процесса разработки и поддержки ПО. Библиотеки подпрограмм тестируются многими пользователями~\footnote{В данном случае в качестве пользователей выступают программные инженеры, которые используют эти библиотеки в своих программных продуктах.}. Чем дольше используется библиотека тем больше ошибок в ней найдено и исправлено.

Подпрограммы являются исторически первым средством в арсенале инженера-программиста. Они появились вместе с первыми универсальными ЭВМ и существуют и активно используются до сих пор. В~\cite{Dijkstra:1972:HP} Эдсгер Дейкстра называет концепцию подпрограмм первой существенным достижением ПИ. В своей Тьюринговской лекции в 1972 году он говорит, что подпрограммы пережили три поколения ЭВМ и переживут еще несколько. Трудно не согласится с Дейкстрой о важности подпрограмм в ПИ. Они как и предсказывал Дейкстра дожили до наших дней~\footnote{А это уже больше 30 лет.}, и нет никаких признаков того, что они скоро уйдут в сторону. Однако называть подпрограммы достижением ПИ не вполне корректно. Вряд ли инженер-электротехник проектирует каждое устройство оперируя только транзисторами, он использует уже готовые электронные схемы, решающие какие-то задачи. Что фактически эквивалентно использованию подпрограмм инженерами-программистами.

Итак, концепция подпрограммы является, во-первых, довольно общей. На протяжении истории ПИ идея подпрограммы приобретала различные реализации: конкретная последовательность команд решающих какую-то задачу и мета-функции, чистые функции и функции с побочными эффектами и др. Нельзя отнести идею подпрограммы к какой-то конкретной парадигме программирования, так как многие из них так или иначе опираются на эту идею. Во-вторых, как отмечалось ранее, идея подпрограммы не является специфичной идеей ПИ инженерии, а скорее унаследована из общих инженерных принципов, которые, в свою очередь, объясняются не возможностью человеческого мозга оперировать слишком большим числом понятий.
