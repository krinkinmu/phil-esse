\section{Освоение процесса}

Начало этого обычно связывают с появлением программно-аппаратной системы IBM-360 (ЭВМ и базовый набор ПО для этой системы). Разработка огромного по тем меркам программного проекта вскрыла многие проблемы ПИ. Менеджер проекта Фредерик Брукс в последствии написал книгу «The Mythical Man-Month: Essays on Software Engineering», основанную на полученном опыте, которая до сих пор очень популярна.

С появлением мощной и универсальной ЭВМ IBM-360 исчезла необходимость постоянного переписывания программ под новые системы (IBM-360 использовалась с 1965 по 1978 год~\cite{IBM360}). IBM-360 использовалась повсеместно, как в научных так и в бизнес приложениях.

Ключевым историческим моментом в этом периоде стали конференции НАТО по ПИ 1968 и 1969 годов, которые привлекли внимание к кризису ПО~\cite{CRISIS}. Как уже упоминалось ранее, именно с этим событием обычно связывают самое появление понятия ПИ. В чем же заключался кризис ПО?  За более чем пятнадцать лет был накоплен некоторый опыт разработки ПО. Проблема заключалась в том, что этот опыт был во многом неудачным~\footnote{Например, разработка OS/360 (операционной системы IBM-360) стоила сотни миллионов долларов, превысила сроки больше чем на год и содержала огромное количество ошибок.}. Многие проекты так и не были доведены до конца, либо были доведены до конца с превышением бюджета, сроков, или ненадлежащим качеством. С ростом мощности вычислительной техники возрастают и ожидания людей от ЭВМ, а вместе с ними и сложность программных проектов. Широкое распространение ЭВМ привело к росту спроса на новое ПО, который просто не удавалось удовлетворить~\cite{Dijkstra:1972:HP},~\cite{CRISIS}. Стала очевидной необходимость систематического подхода к разработке ПО. Разработка ПО — должна быть предсказуемой, управляемой.

Именно на этом этапе появляются первые методологии процесса разработки ПО. Эти методологии предполагают планирование всего процесса разработки на начальном этапе. Поэтому основновное внимание они уделяют фазе сбора и анализа требований к программному продукту, т. е. фазе постановки задачи. На этом этапе появляется и первая распространенная парадигма программирования - структурное программирование.

Методологические разработки этого задают ориентацию на создание больших программных систем. Они начинают уделять внимание фазам процесса разработки ПО, особенно фазе сбора и анализа требований, т. е. фазе постановки задачи (~\cite{Alford:1976:REM},~\cite{Ross:1977:SA}). Другая часть разработок направлена непосредственно на организацию структуры программы и доказательство ее корректности. В этой области выделяется разработка парадигмы структурного программирования с ее строгими математическими основаниями и формальным подходом к проверке корректности программ.

\subsection{Структурное программирование}

Структурное программирование включает три взаимосвязанные части: самоограничение программиста в используемых средствах структурирования программы, подход сверху-вниз при проектировании программы и формальное доказательство корректности программ.

\paragraph{Самоограничение} заключалось в том, что простые предложения языка программирования и составные конструкции связываются в единую программу только с помощью трех структурных конструкций: последовательное исполнение, ветвление и цикл. Все эти конструкции имеют только один вход и один выход, т. е. нельзя передать управление в середину цикла не пройдя через точку входа в цикл, и нельзя выйти из цикла не пройдя точку выхода. Языки программирования того времени~\footnote{И современные языки тоже.} предоставляли и другие конструкции управления потоком исполнения программы, в частности, печально известную GOTO. Именно на нее и направили свою критику представитили структурного программирования~\cite{Dijkstra:1968:LEG}. Такая критика не была воспринята однозначно. Дональд Кнут написал статью, в которой выделил несколько задач, в которых GOTO является оптимальной конструкцией~\cite{Knuth:1974:SPG}. Но, в целом программисты пришли к согласию, что конструкцию GOTO легко использовать неправильно.

Изначально совсем не очевидно, что такое ограничение не сократит множества возможных программ. Однако структурное программирование имело строгие математические основания, одним из которых была структурная теорема~\cite{SPT}, доказанная Бёмом и Якопини. Суть теоремы как раз и заключалась в том, что фактически любую программу можно написать с помощью трех указанных конструкций.

Пожалуй, это первый известный мне пример самоограничения в программировании, когда инженер намеренно отказывается от использования некоторых возможностей в пользу понятности программы. До этого программисты пытались "выжать все" из ЭВМ, поэтому старались использовать все ее возможности. И программы были наполнены множеством нетривальных трюков и уловок нацеленных на большую эффективность.

\paragraph{Проектирование больших программ} стало еще одной проблемой, которую было призвано решить структурное программирование. Дейкстра отмечает, что одной из причин кризиса ПО стал рост мощности ЭВМ~\cite{Dijkstra:1972:HP}. Который в свою очередь привел к росту ожиданий пользователей от ЭВМ. Люди начинают применять ЭВМ во все более сложных задачах и ПО, по необходимости, тоже становится сложнее. Подход "Code and Fix" более не пригоден для разработки, и структурное программирование предлагает первое решение - проектирование сверху-вниз. Суть подхода заключается в последовательном разделении большой задачи на подзадачи, которые в свою очередь разделяются на еще более маленькие подзалачи и так до тех пор, пока мы не придем к задаче, которую лекго можно решить на ЭВМ. После чего идет обратный процесс - полученные решения простых задач объединяются в решения более сложных и так далее.

Сейчас можно сказать, что в подходе нет ничего революционного, мы бы могли назвать его очевидным. Но в то время, когда не было никакого систематического подхода к разработке ПО, он стал важным шагом и привлек внимание к проблеме. Кроме того стоит отметить, что пропагандисты структурного программирования успешно демонстрировали применение этого подхода на практике. Причем как на простых примерах~\cite{Wirth:1971:PDS}, так и на реальных проектах. Например, известный проект по созданию системы индексации для New York Time выполненый Харланом Милсом. Сложность проекта была оценена в 30 человеко-лет, но Милс закончил его самостоятельно за 6 месяцев~\cite{Aron:1979:SP}. В связи с чем структурное программирование приобрело определенную популярность.

\paragraph{Корректность программ} стала еще одной важной проблемой, которую должно было решить структурное программирование. Действительно, человек доверят компьютеру решение задач, с которыми он не может справится самостоятельно. Но программы для ЭВМ создаются людьми, а они неизбежно ошибаются. Как можно доверять результату работы программы, если нет никаких сопсобов проверить правильность этого результата?

Важность тестирования в последнее время только возрастает. Во основном в связи с тем, что чем раньше будет найдена проблема в ПО, тем меньше будет стоимость ее устранения. В работе [18] приведены примеры финансовых потерь из-за программных ошибок, сделан обзор методологий тестирования и разработана математическая модель стоимости программных ошибок. Стоит отметить, что ошибки в ПО могут приводить не только к финансовым потерям, но иногда могут стоить и жизни людей.

Корректности программ и до появления структурного программирования уделялось некоторое внимание~\footnote{Его нельзя назвать систематичным подходом.}. Основным инструментом проверки корректности программ было~\footnote{И остается на сегодняшний день.} тестирование. Т. е. результат работы программы сравнивается с известными правильными результатами на некотором ограниченном наборе тестов. Критический недостаток тестирования как средства проверки ПО заключается в том, что он дает некоторый уровень уверенности в правильности программы, но не дает гарантий корректности. Даже небольшие программы имеют огромное количество внутренних состояний и возможных путей исполнения. Протестировать все пути исполнения нет никакой физической возможности~\footnote{Их число измеряется астрономическими величинами, запустить тест для каждого варианта просто не хватит времени.}. Более того, в этом нет никакого смысла — если бы были известны правильные результаты работы программы на всех входных данных, то сама программа была бы не нужна. Тестирование может показать наличие ошибок в ПО, но никогда не сможет доказать их отсутствие~\cite{Dijkstra:1972:CIN}~\footnote{Однако в некоторых ситуациях инженеры готовы примериться с возможным наличием ошибок в ПО.}.

В рамках структурного программирования развивался альтернативный формальный подход к корректности программ. Т. е. правильность программы доказаывалась строгими маетматическими методами. Структурное программирование ввело в ПИ такие понятия как предусловие, постусловие и инвариант. Предусловие - это формальное логическое утверждение, которое выполняется перед началом некоторого участка программы. Постусловие - это формальное логическое утверждение, которое истинно по завершению участка программы, если предусловие было истинно. Инвариант - это формальное логическое утверждение, которое должно быть истинно перед и по окончанию каждой итерации цикла, т. е. оно совмещает понятия предусловия и постусловия для циклов. Доказательство корректности программы выполняется следующим образом:
\begin{enumerate}
  \item формулируется предусловие, которое описывает ограничения и взимосвязь входных данных;
  \item из предусловия последовательно для каждой структурной единцы участка программы выводится постусловие, которое становится предусловием для следующей структурной единицы, и так до тех пор пока мы не получим постусловие для всего участка программы;
  \item если из постусловия участка программы логически следует правильность результата, то корректность программы доказана.
\end{enumerate}

Математические основания такого способа доказательсва корректности была заложены в работе Чарльза Хоара~\cite{Hoare:1969:ABC}, а в работе~\cite{Dijkstra:1972:CIN} Дейкстра развивает подход и описывает несколько паттерном или приемов, которые могут оказаться полезными при таком доказательстве корректности программ~\footnote{В частности он демонстрирует использрование математической индукции применительно к циклам, и описывает паттерн перечиления.}.

Такое формальное доказательство не получилос широко распространения в индустрии, потому что этот подход не подлежал автоматизации и плохо масштабировался на большие программы. Фактически доказательство корректности программ было похоже на доказательство математической теоремы. Кроме того представители структурного программирования не предлагали каких-то формальных механических методов для формулировки предусловий и инвариантов. Однако этот подход стал первым формальным методом.

\subsection{Водопад}

Методология выделяет фазы процесса разработки ПО, определяет взаимные переходы между этими фазами, а также результаты выполнения каждой из фаз. «Водопад» — стал первой формально описанной методологией организации процесса разработки ПО~\cite{Royce:1987:MDL}. В этой методологии выделяются следующие фазы: анализом и спецификация требований, дизайн программы, реализация или кодирование, тестирование, развертывание и поддержка. Фазы процесса идут ровно в таком порядке, возможно, в случае обнаружения ошибок происходит возврат на один шаг назад.

Сейчас «водопад» относят к так называемым жестким методологиям. Это значит, что в методологии особенно важны первые этапы связанные с анализом и спецификацией требований, они занимают самую большую часть времени процесса разработки. Фактически этот этап определяет план всей дальнейшей работы. После фиксации требований и разработки дизайна программы вернуться назад к анализу требований довольно проблематично — фактически это означает начать работу заново. Именно поэтому «водопад» называют жесткой методологией, в противовес гибким методологиям. В целом эта методология следует тенденциям того времени. После осознания необходимости правильной организации процесса разработки ПО, первое что привлекло внимание — фаза постановки задачи и планирования.

В ответ на недостатки «водопада» появилось несколько различных его модификаций, например, «сашими» - в отличие от «водопада», фазы не следуют строго друг за другом, а частично перекрываются во времени. На данный момент, «водопад» и его развития несколько уступили позиции гибким итеративным методологиям, но все еще используются в крупных компаниях, для которых в первую очередь важна предсказуемость процесса разработки.

\subsection{UNIX}

Говоря об этапе стабилизации нельзя обойти стороной такую значительную разработку как UNIX. Многие технологии появились вместе с и благодаря UNIX. Начиная от специфичных средств разработки ПО в их современном виде — текстовые редакторы и отладчики, заканчивая такими глобальными технологиями как Интернет.

UNIX — многопользовательская, интерактивная операционная система, предок современных операционных систем. Первая версия была разработана в 1969 году Денисом Ритичи и Кеном Томпсоном~\cite{Ritchie:1974:UTS}. Основным достижением UNIX, по мнению создателей, является ее простота. Они показали, что мощная операционная система не обязана быть сложной или очень дорогой (имеется ввиду стоимость разработки, разработка UNIX заняла меньше чем два человека-года).

Операционной системе UNIX программная инженерия в первую очередь обязана за «философию Unix». Философия Unix включает в себя ряд принципов, которыми стоит руководствоваться при проектирование ПО. Дуглас Макилрой формулирует принципы философии Unix следующим образом~\cite{McIlroy:1978:UTS}:
\begin{itemize}
  \item каждая программа должна делать одну вещь, но делать ее хорошо; для новой задачи реализуйте новую программу, а не усложняйте уже существующую новыми возможностями;
  \item рассчитывайте на то, что вывод программы, станет входом для другой программы, возможно еще не известной; не засоряйте вывод программы лишней информацией; избегайте бинарных форматов; не настаивайте на интерактивном вводе;
  \item проектируйте и реализуйте программное обеспечение так, чтобы его можно было попробовать как можно раньше; не бойтесь выкидывать неуклюжие части и переписывать их заново;
  \item предпочитайте программные утилиты человеческому труду, чтобы облегчить задачи разработки ПО.
\end{itemize}

Не все эти принципы можно трактовать однозначно положительно, в частности часть третьего пункта про выкидывание частей программы требует аккуратности, как показывает опыт ПИ. Но основные концепции — стремление к простоте, модульность, быстрое прототипирование и автоматизация, на много лет вперед определели содержание «хорошего стиля» программирования.
